# سرور و کلاینت
+ شما باید کد هوش مصنوعی خود را در تابع turn که در فایل AI.java (در تمامی کلاینت‌ها فایلی با همین اسم قرار دارد)، پیاده‌سازی کنید.

+ شما می‌توانید کد کلاینت داده شده را تغییر دهید، به آن فایل اضافه کنید یا از آن فایل حذف کنید، به شرط آنکه تغییرات داده شده در کامپایل و اجرای کلاینت و ارتباط آن با سرور اختلالی ایجاد نکند. در مورد هر کلاینت نکاتی ذکر شده که به آن‌ها نیز باید توجه شود. همچنین باید تغییرات احتمالی فایل‌های دیگر کلاینت، یعنی فایل‌هایی غیر از فایلی که در آن کد می‌زنید) را در نظر بگیرید.

+ شما می‌توانید برای به روز بودن کلاینت‌ها یا سرور خود به آخرین نسخه منتشر شده در repository مسابقه مراجعه کنید.
  
  * [کلاینت C++](https://github.com/SharifAIChallenge/AIC21-Client-Cpp)
  * [کلاینت Java](https://github.com/SharifAIChallenge/AIC21-Client-Java)
  * [کلاینت Python](https://github.com/SharifAIChallenge/AIC21-Client-Python)

+ نکته‌ی قابل توجه در مورد کلاینت، این است که برای هر کدام از نیروها، چه مورچه‌ها و چه عقرب‌ها، یک بار به طور جداگانه کد کلاینت اجرا می‌شود. در نتیجه نیروها حافظه‌ی مشترکی با یکدیگر ندارند و تنها راه ارتباطی آن‌ها از طریق چت باکس می‌باشد (توضیحات چت‌باکس را در [مستند بازی](https://aichallenge.ir/dashboard/doc/Game-Doc#%D8%A7%D8%B1%D8%AA%D8%A8%D8%A7%D8%B7-%D9%86%DB%8C%D8%B1%D9%88%E2%80%8C%D9%87%D8%A7) بخوانید).

## کلاینت جاوا

کلاینت‌های جاوا، برای اجرا توسط سرور، باید به فایل jar تبدیل شوند. برای ساخت فایل jar کلاینت جاوا، باید از Intellij استفاده کنید. در Intellij، از مسیر زیر می‌توانید فایل jar رابسازید.  

`File --> Project Structure --> Project Settings --> Artifacts --> green plus sign --> Jar --> From modules with dependencies`

![jar](https://github.com/SharifAIChallenge/AIC21-Doc/blob/master/images/jar.png?raw=true)

هر بار که تغییری در کد کلاینت داده شد، برای اجرا باید یک فایل jar تازه ساخته‌شود. مراحل ساخت فایل jar و اطلاعات بیشتر را در [داکیومنتیشن Intellij](https://www.jetbrains.com/help/idea/compiling-applications.html#compile_module) و همچنین [این پست در Stack Overflow](https://stackoverflow.com/questions/1082580/how-to-build-jars-from-intellij-properly) نیز می‌توانید مشاهده کنید.

## کلاینت پایتون

برای اجرای کلاینت‌های پایتون، باید کدها و تمامی dependency ها در یک پکیج تجمیع شود (Binary). این کار با ابزار [Pyinstaller](https://pypi.org/project/pyinstaller/) به راحتی امکان‌پذیر است. برای نصب این پکیج، می‌توانید از دستور pip install pyinstaller استفاده کنید. اگر pip را نصب ندارید، طریقه‌ی نصب آن روی سیستم‌عامل‌های مختلف، از لینک‌های زیر مشاهده کنید:  

  * [Windows](https://phoenixnap.com/kb/install-pip-windows)

  * [Linux](https://www.tecmint.com/install-pip-in-linux/)

  * [Mac OS](https://ahmadawais.com/install-pip-macos-os-x-python/)

دقت کنید که پس از هر بار تغییر در کد، پوشه های build و dist را پاک کنید و مجددا با PyInstaller بیلد بگیرید.

## کلاینت سی‌پی‌پی
### Unix ‌Based
برای دریافت و اجرای کلاینت، دستورات زیر را اجرا کنید.
```
cd path/to/working/directory
git clone --depth=1 https://github.com/SharifAIChallenge/AIC21-Client-Cpp
cd AIC21-Client-Cpp
mkdir build
cd build
cmake ..
make
```

بعد از هر تغییر در فایل‌ها، فقط باید دستور make را بزنید. اگر یک فایل جدید به پروژه اضافه یا فایلی را از پروژه حذف کردید، ابتدا دستور `cmake ..` و سپس دستور `make` را اجرا کنید.

### Windows
برای اجرای بیلد کردن کلاینت روی سیستم‌عامل ویندوز، باید از ابزار cygwin استفاده کنید. برای نصب cygwin و راه‌اندازی کلاینت، می‌توانید مطابق راهنمای ذکر شده در فایل [README.md](https://github.com/SharifAIChallenge/AIC21-Client-Cpp#windows) در ریپو کلاینت سی‌پلاس‌پلاس پیش روید. مراحل به طور کامل و با تصویر توضیح داده شده‌اند.

## اجرای سرور
برای اجرای سرور، بهتر از java 11 به بالا استفاده کنید.
ابتدا آخرین نسخه ریلیز سرور را از [این‌جا](https://github.com/SharifAIChallenge/AIC21-Game/tree/main/server) دانلود کنید (فایل server.jar).  
فایل map.config را از [ریپوی گیم](https://github.com/SharifAIChallenge/AIC21-Game/blob/main/server/map.config) دریافت کنید د در کنار سرور قرار دهید.  
سپس سرور را به این شکل اجرا کنید:   
`java -jar server.jar --first-team=/path/to/first/client --second-team=/path/to/second/client --read-map=/path/to/map/json/file`
  
در بالا دو آرگومان اول محل قرار گیری فایل کلاینت برای تیم اول و تیم دوم را مشخص می کنند.  این فایل برای کلاینت جاوا همان فایل jar تولید شده است ، برای کلاینت پایتون خروجی باینری و برای کلاینت cpp همان خروجی حاصل از بیلد گرفتن کلاینت است.   
برای اجرای سرور به دو فایل کانفیگ نیاز است. فایل map.config باید با همین نام با سرور در یک پوشه باشد. فایل map.json برای خواندن اطلاعات جزئی نقشه است. درصورتی که مقدار متغیر READ_MAP_FROM_FILE در فایل map.config برابر false باشد، سرور اقدام به تولید نقشه تصادفی می کند. اگر این متغیر true باشد، سرور ابتدا در پوشه فعلی دنبال فایل دوم یعنی map.json می گردد. اگر این فایل وجود نداشت باید با آرگومان —read-map این فایل به سرور داده شود. همانند مثال 

برای توضیحات بیشتر به ریپازیتوری سرور مراجعه کنید.
  
دقت کنید که اگر فایل کلاینت یا مپ شما در پوشه سرور قرار دارد (مثلا نام آن client است) از ./ در ابتدای آن استفاده کنید:  
`--first-team=./client`

برای نمایش لاگ بیشتر از سرور جهت دیباگ کردن (و همچنین نمایش خروجی کلاینت ها در لاگ سرور) از آرگومان `--show-log` نیز  می‌توانید استفاده کنید.  
مثال:   
`java -jar server.jar --first-team=/path/to/first/client --second-team=/path/to/second/client --show-log`
  
با استفاده از آرگومان ```--max-agent``` می توانید یک کران بالا برای تعداد نیرو های ساخته شد (instance های اجرایی از کلاینت) تعیین کنید تا سیستم شما دچار مشکل در اجرا نشود (پیشنهاد ما حداکثر ۵۰ است)

مثال:  
 `java -jar server.jar --first-team=/path/to/first/client --second-team=/path/to/second/client --max-agent=20`
 این مقدار به طور پیش فرض 200 در نظر گرفته می شود.
در صورت تمایل به اجرای کلاینت ها بصورت دستی، می توانید از آرگومان `--run-manually` استفاده کنید. در این صورت هر موقع سرور منتظر وصل شدن کلاینت جدید ماند، باید یک instance از کلاینت خود را دستی اجرا کنید. در این صورت می توانید به طور کامل لاگ کلاینت را در کنسول مشاهده کنید. (در این صورت توصیه می شود از اعداد کوچک برای `inital_ant_num` در `map.config` استفاده کنید.)

+ برای تست کردن کد، با تعداد کم نیرو این روش بسیار مفید خواهد بود. ضمن این که برای اجرا در این روش نیازی به خروجی گرفتن از کلاینت نیست.  

+ دقت کنید که هرموقع نیاز به کلاینت جدید بود، سرور در خروجی ای رشته را چاپ می کند:  
`Run a new instance of your client, waiting...`

## نکات
### بازی
در کلاینت‌ها، زمین بازی و خانه‌های آن (Cell) طبق مختصات زیر مقداردهی می شوند:

+ خانه‌ی بالا چپ زمین مختصات (0,0) دارد.
+ مقدار x برای هر خانه، شماره ستون آن (از چپ) است.
+ مقدار y برای هر خانه، شماره سطر آن (از بالا) است. 

در مورد کلاینت‌ها نکات زیر قابل توجه هستند:

+ در بین دستوراتی که از کلاینت‌ها به سرور فرستاده می‌شود، در صورت نامعتبر بودن یک دستور، این دستور نادیده گرفته می‌شود.
+ رفرنس شی World و شی‌های درونی آن در هر نوبت از ابتدا ساخته می‌شود رفرنس‌های نوبت قبل در نوبت فعلی معتبر نیستند.
+ نام توابع و کلاس‌ها در تمامی کلاینت‌ها (سی‌پی‌پی، پایتون و جاوا) یکسان است.

### سایر توضیحات

+ اطلاعات نقشه بازی در یک فایل به نام `map.config` در کنار سرور بازی باید قرار بگیرد که نمونه ی آن را در ریپو سرور می توانید پیدا کنید. 

+ خروجی گرافیکی سرور پس از پایان یک بازی در یک فایل به نام `log.json` در کنار سرور قابل دسترسی است.

+ در هنگام اجرای سرور حتما به درست وارد کردن آدرس کلاینت های بازی دقت کنید!

+ برای مطمین شدن از این که سرور کار خود را با موفقیت به پایان رسانده است، در خروجی باید winner مشخص شده باشد. (نه لزوما خط آخر)

## توابع و کلاس‌های اصلی کلاینت

`Answer turn(World)`

این تابع در هر نوبت بازی صدا زده می شود. هر نیرو در آن نوبت یک شی Answer تولید می‌کند که از جهت حرکت نیرو و پیام (در صورت ارسال پیام) و ارزش آن تشکیل شده است.  

### World/Game

`Ant getAnt()`
اطلاعات آن نیرو را برمی‌گرداند.

`AntType getAntType()`

نوع نیرو فعلی را برمی گرداند که یکی از دو حالت `SARBAAZ` و یا `KARGAR` است.

`ChatBox getChatBox()`

اطلاعات چت باکس تیم نیرو فعلی را بر می‌گرداند. ( لیستی از پیام ها و نوبتی که در آن پیام ارسال شده است)

`int getMapWidth()`

عرض زمین بازی را برمی گرداند.

`int getMapHeight()`

ارتفاع زمین بازی را برمی گرداند.

`int getBaseX()`

مختصات X پایگاه تیم نیرو فعلی را بر می گرداند.

`int getBaseY()`

مختصات Y پایگاه تیم نیرو فعلی را بر می گرداند.

`int getHealthKargar()`

مقدار جان اولیه کارگر را بر می گرداند.

`int getHealthSarbaaz()`

مقدار جان اولیه نیرو های سرباز را بر می گرداند.

`int getAttackDistance()`

فاصله منهتنی برای حمله نیرو سرباز را برمی گرداند.

`int getGenerateKargar()`

مقدار منبع مورد نیاز برای تولید کارگر را برمی گرداند.

`int getGenerateSarbaaz()`

مقدار منبع مورد نیاز برای تولید سرباز را برمی گرداند.

`int getRateDeathResource()`

مقدار پارامتر `rate_death_resource` را برمی گرداند.

### Ant

`Cell getMapCell(int xStep, int yStep)`

خانه مربوطه بر روی نقشه را در صورتی که در دید نیرو باشد (view_distance) بر می گرداند. (اگر در دید نیرو فعلی نباشد، این مقدار null بر می گرداند)

`int getXCoordinate() `

مختصات X خانه فعلی نیرو را بر می گرداند.

`int getYCoordinate() `

مختصات Y خانه فعلی نیرو را بر می گرداند.

`AntType getType()`

نوع نیرو فعلی را بر می گرداند

`AntTeam getTeam()`

تیم نیرو را بر می گرداند. (شی Ant برای نیرو های خانه های همسایه نیز قابل استفاده است).

* ALLIED → هم تیمی نیرو فعلی

* ENEMY → تیم مقابل نیرو فعلی

`Resource getCurrentResource()`

مقدار و نوع منبعی که نیرو فعلی حمل می کند را بر می گرداند.

`int getHealth()`

میزان جان مورجه فعلی را بر می گرداند.

`getViewDistance()`

مقدار پارامتر `view_distance` را برای نیرو فعلی بر می گرداند.

## گزارش مشکلات

در صورتی که در اجرای سرور به مشکلی بر خوردید، از طریق سایت، یک تیکت در قالب زیر برای ما ارسال کنید:

+ .شرح مشکل پیش آمده

+ کدی که در بخش AI برای کلاینت خود زدید بعلاوه نوع کلاینتی که استفاده می کنید.

+ لاگ خروجی سرور پس از اجرا که در آدرس `Log/server/server.log` در کنار سرور قرار می‌گیرد ( برای خروجی مفصل تر،‌ سرور را با `--show-log` اجرا کنید سپس این فایل را بفرستید).

+ فایل `map.config` استفاده شده.

+ کامندی که با آن سرور را اجرا می‌کنید (با آرگومان‌ها).

در صورتی که در اجرا و کارکردن با هر یک کلاینت ها به مشکل برخوردید، از طریق سایت، یک تیکت در قالب زیر ارسال کنید:

+ شرح مشکل پیش آمده.

+ نوع کلاینتی که استفاده می‌کنید (پایتون، جاوا یا سی‌پی‌پی).

+ کد کامل کلاینت به صورت فشرده (zip)

# گرافیک
## اجرا
تماشای بازی‌ها به صورت گرافیکی نیز امکان‌پذیر است. بعد از اجرای سرور که پیش‌تر مراحل آن توضیح داده شد، می‌توانید با اجرای رابط گرافیکی بازی و ایمپورت کردن فایل log.json که سرور بعد از اجرای بازی آن‌را تولید می‌کند، اتفاقات بازی را به صورت گرافیکی مشاهده کنید.  
با کلیک کردن بر روی فایل graphic.exe برنامه گرافیک بازی را باز کنید و با کلیک روی دکمه‌ی Browse GameLog، آدرس فایل log.json تولید شده توسط سرور را به آن بدهید.
پس از آن می‌توانید بازی را به صورت گرافیکی مشاهده کنید.
توجه کنید که روی سیستم‌عامل‌های unix based، ابتدا باید با اجرای دستور`chmod +x /path/to/graphic/file` آن را قابل اجرا کنید.

![AIC21-Game](https://github.com/SharifAIChallenge/AIC21-Doc/blob/master/images/import.png?raw=True)
  
 ## نوار امکانات
در بالای رابط گرافیکی، نواری‌ست که امکانات و هم‌چنین اطلاعاتی از بازی در اختیار شما قرار می‌دهد. این اطلاعات و امکانات به شرح زیر‌اند:  
  
![bar](https://github.com/SharifAIChallenge/AIC21-Doc/blob/master/images/Bar.png?raw=true)
  
۱- این دکمه چت باکس هر تیم را نشان میدهد.  
۲- در این قسمت اسم هر تیم نشان داده میشود.  
۳- این بخش مربوط به turnهای بازی‌ست. با کلید سمت راست، به نوبت بعد و با کلید سمت چپ، به نوبت قبل می‌توان رفت. عدد بین دو دکمه، تعداد کل حرکت‌های بازی و حرکت در حال نمایش را نشان می‌دهد. به طور مثال، در این عکس، بازی در کل ۱۰۰ حرکت دارد که اکنون در حرکت ۲۰ام هستیم.  
۴- این دو نوار، میزان سلامتی هر کدام از   
۵- این بخش تعداد مورچه های در اختیار تیم را نشان میدهد.  
۶- این بخش تعداد عقرب های در اختیار تیم را نشان میدهد.  
۷- این بخش میزان گندم در اختیار تیم را نشان میدهد.  
۸- این بخش میزان علف در اختیار تیم را نشان میدهد.  
۹- در این قسمت، سرعت پخش بازی مشخص می‌شود. با زدن دکمه‌ی سمت راست، سرعت پخش ۲ برابر و با زدن دکمه‌ی سمت چپ، نصف می‌شود. با کلیک روی دکمه‌ی میانی نیز بازی متوقف (pause) می‌شود. عدد زیر دکمه‌ی توقف، سرعت فعلی پخش بازی را نشان می‌دهد.   
۱۰- برای رفتن به یک حرکت خاص، می‌توانید شماره ی حرکت مورد نظر را در باکس بنویسید و سپس با زدن دکمه ی Apply Turn به آن حرکت بروید.  
۱۱- با زدن این دکمه میتوانید صدای بازی را قطع یا وصل کنید.  

## نکات
+ .با نگه‌داشتن دکمه‌ی وسط موس، می‌توان مپ را جابه‌جا کرد
+ با اسکرول کردن روی صفحه، می‌توان zoom in و zoom out کرد.

## گزارش مشکلات
مشکلات و ایرادات پیش آمده در گرافیک بازی را از طریق سایت با ارسال تیکت در قالب زیر، با ما در میان بگذارید:
+ شرح مشکل پیش‌آمده
+ .تصویر یا تصاویری از مشکل پیش‌آمده
+ فایل log.json که در گرافیک در حال اجرای آن بوده.
